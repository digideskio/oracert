
/*
Beginning with Oracle Database 12c, you can specify a maximum size of 32767 bytes for 
the VARCHAR2, NVARCHAR2, and RAW data types. You can control whether your database 
supports this new maximum size by setting the initialization parameter 
MAX_STRING_SIZE as follows:

If MAX_STRING_SIZE = STANDARD, then the size limits for releases prior 
to Oracle Database 12c apply: 4000 bytes for the VARCHAR2 and NVARCHAR2 
data types, and 2000 bytes for the RAW data type. This is the default.

If MAX_STRING_SIZE = EXTENDED, then the size limit is 32767 bytes for 
the VARCHAR2, NVARCHAR2, and RAW data types.

Note:
Setting MAX_STRING_SIZE = EXTENDED may update database objects and possibly 
invalidate them. Refer to Oracle Database Reference for complete information 
on the implications of this parameter and how to set and enable this new 
functionality.


Creating an Index on an Extended Data Type Column 
If column is an extended data type column, then you may receive a 
"maximum key length exceeded" error when attempting to create the index. 
The maximum key length for an index varies depending on the database block 
size and some additional index metadata stored in a block. For example, for 
databases that use the Oracle standard 8K block size, the maximum key length 
is approximately 6400 bytes.

To work around this situation, you must shorten the length of the values you 
want to index, using one of the following methods:

- Create a function-based index to shorten the values stored in the extended 
  data type column as part of the expression used for the index definition.

    CREATE INDEX index ON table (SUBSTR(column, 0, n));

- Create a virtual column to shorten the values stored in the extended data 
  type column as part of the expression used for the virtual column definition 
  and build a normal index on the virtual column

    ALTER TABLE table ADD (new_hash_column AS (STANDARD_HASH(column)));
    CREATE INDEX index ON table (new_hash_column);
*/

/*
ROWID Data Type
The rows in heap-organized tables that are native to Oracle Database have row 
addresses called rowids. You can examine a rowid row address by querying the 
pseudocolumn ROWID. Values of this pseudocolumn are strings representing the 
address of each row.

Rowids are stored as base 64 values that can contain the 
characters A-Z, a-z, 0-9, and the plus sign (+) and forward slash (/)

The data block of the data file containing the row. The length of this string depends on your operating system.

The row in the data block.

The database file containing the row. The first data file has the number 1. The length of this string depends on your operating system.

The data object number, which is an identification number assigned to every 
database segment. You can retrieve the data object number from the data 
dictionary views USER_OBJECTS, DBA_OBJECTS, and ALL_OBJECTS. Objects that 
share the same segment (clustered tables in the same cluster, for example) 
have the same object number.


UROWID Data Type
The rows of some tables have addresses that are not physical or permanent or 
were not generated by Oracle Database. For example, the row addresses of 
index-organized tables are stored in index leaves, which can move. Rowids of 
foreign tables (such as DB2 tables accessed through a gateway) are not standard 
Oracle rowids.

Oracle uses universal rowids (urowids) to store the addresses of index-organized
and foreign tables. Index-organized tables have logical urowids and foreign tables 
have foreign urowids. Both types of urowid are stored in the ROWID pseudocolumn 
(as are the physical rowids of heap-organized tables).

Oracle creates logical rowids based on the primary key of the table. The logical 
rowids do not change as long as the primary key does not change
*/

/*
Character Datatypes

CHAR(size BYTE|CHAR)
------------------------------------
Fixed-length character data of length size bytes or characters. 
Maximum size is 2000 bytes or characters. Default and minimum size is 1 byte.

The CHAR data type specifies a fixed-length character string. Oracle ensures 
that all values stored in a CHAR column have the length specified by size. 
If you insert a value that is shorter than the column length, then Oracle 
blank-pads the value to column length. If you try to insert a value that is
too long for the column, then Oracle returns an error.
*/

-- defaults its size to 1 
create table chartab (c1  char);
insert into chartab(c1) values ('a');  -- Must success
insert into chartab(c1) values ('ab'); -- Must fail
drop table chartab;

-- Max size is 2000
create table chartab (c1  char(2000));
insert into chartab(c1) values ('ab'); -- Must success
select 'Columns has been filled upt to '||length(c1)||' chars' as msg 
  from chartab where length(c1) = 2000; 
drop table chartab1;
create table chartab (c1  char(2001));

/*
VARCHAR2(size BYTE|CHAR)
------------------------------------
Minimum size is 1 (char|byte)
Maximum size is:

  before 12c
    4000

  since 12c
    4000 bytes or characters if MAX_STRING_SIZE = STANDARD
    32767 bytes or characters if MAX_STRING_SIZE = EXTENDED
*/
create table varchar2tab (c1  varchar2(20) ); 
insert into varchar2tab(c1) values ('a');  -- Must success
insert into varchar2tab(c1) values ('ab'); -- Must fail
drop table varchar2tab;

/*
number datatypes
-----------------
NUMBER(precision, scale)
FLOAT(precision)
BINARY_FLOAT
BINARY_DOUBLE

*/

--> * NUMBER(n,m) * <--
-- precision (n) ranges from 1 to 38 
-- scale (m) ranges from -84 to 127 and defaults to 0 when n is specified
-- These are NOT the largest values !!
-- values range from 1.0 * 10^-130 to (but not including) 1.0 * 10^126
create table numtab (c1  number ); 
insert into numtab (c1) values (12345678901234567890123456789012345678);
insert into numtab (c1) values (123456789012345678901234567890123456789); 
insert into numtab (c1) values (12345678901234567890123456789012345678901234567890);
insert into numtab (c1) values (3.44);
select 'Trovato' from numtab where c1 = 3.44;
select 'Trovato' from numtab where c1 = 123456789012345678901234567890123456789;
drop table numtab;

create table numtab (c1  number(5) ); -- number(5,0)
insert into numtab (c1) values (12345);
insert into numtab (c1) values (123456); -- must fail
insert into numtab (c1) values (3.4); -- inserts 3
select 'Trovato' from numtab where c1 = 3.4;
select 'Trovato' from numtab where c1 = 3;
insert into numtab (c1) values (3.8); -- inserts 4
select 'Trovato' from numtab where c1 = 3.8;
select 'Trovato' from numtab where c1 = 4;
drop table numtab;

/* 

Negative scale has the effect of "increasing" the precision:
Notice the examples below: precision (n) defines the maximum number on digits
on the left of the "m" zeroes
*/
create table numtab (c1  number(5,-2) ); -- number(5,0)
insert into numtab (c1) values (3.4); -- inserts 0
insert into numtab (c1) values (44); -- inserts 0
insert into numtab (c1) values (128);  -- 100
insert into numtab (c1) values (12345);  -- 12300
insert into numtab (c1) values (123888); -- 123900
insert into numtab (c1) values (1238883); -- 1238900
insert into numtab (c1) values (12388834); -- must fail!!
insert into numtab (c1) values (3.8); -- inserts 4
select * from numtab;
drop table numtab;


/*
Long and raw datatypes
---------------
LONG
LONG RAW
RAW(size)
*/

/*
date time datatypes
--------------
DATE
    Valid date range from January 1, 4712 BC, to December 31, 9999 AD. 
    The default format is determined explicitly by the NLS_DATE_FORMAT 
    parameter or implicitly by the NLS_TERRITORY parameter. 
    The size is fixed at 7 bytes. This data type contains the datetime 
    fields YEAR, MONTH, DAY, HOUR, MINUTE, and SECOND. 
    It does not have fractional seconds or a time zone.

TIMESTAMP(fp) 
    - The size is 7 or 11 bytes, depending on the precision. 
      This data type contains the datetime fields YEAR, MONTH, 
      DAY, HOUR, MINUTE, and SECOND. It contains fractional 
      seconds but does not have a time zone.

TIMESTAMP(fp) WITH TIME ZONE
	- The size is fixed at 13 bytes. This data type contains the datetime 
	  fields YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, TIMEZONE_HOUR, and 
	  TIMEZONE_MINUTE. 
	  It has fractional seconds and an explicit time zone.

TIMESTAMP(fp) WITH LOCAL TIME ZONE
	- Data is normalized to the database time zone when it is stored in the database.
	- When the data is retrieved, users see the data in the session time zone.

INTERVAL YEAR[(year precision)] TO MONTH 
    Stores a period of time in years and months, where year_precision 
    is the number of digits in the YEAR datetime field. 
    Accepted values are 0 to 9. The default is 2. 
    The size is fixed at 5 bytes.

INTERVAL DAY [(day precision)] TO SECOND [(fractional second precision)]
Stores a period of time in days, hours, minutes, and seconds, where
	- day_precision is the maximum number of digits in the DAY datetime 
	  field. Accepted values are 0 to 9. The default is 2.

	- fractional_seconds_precision is the number of digits in the fractional 
	  part of the SECOND field. Accepted values are 0 to 9. The default is 6.

	The size is fixed at 11 bytes.


*** NOTICE ***
Precision for TIMESTAMP, HOUR, DAY, SECOND ranges from 0 to 9
Default is 6 for TIMESTAMP and SECOND (both have a 'fractional precision')
Default is 2 for YEAR and DAY

*/

select interval '99' day as a_day from dual ; -- default precision is 2
select interval '100' day as a_day from dual ; -- ERROR
select interval '100' day(3) as a_day from dual ; --> SUCCESS!!
select interval '12' minute as a_day from dual ;
select interval '1.333333333' second as a_day from dual ; -- 9 digits is the maximum scale (as for timestamps)

-- the fractional precision doesn't affect the result (it affects columns definition only)
select interval '1.333333333' second(2) as a_day from dual ; 

select interval '100' day(3) + interval '12' minute + interval '3' second as a_day from dual ;
select interval '100' year as x from dual ; -- ERROR!!!
select interval '100' year(3) as x from dual ; -- SUCCESS !

select interval '3' month as x from dual ;

select interval '3' month as x from dual ;

select interval '3' month + interval '26' month as x from dual ;


select current_timestamp + interval '100' day(3) + interval '12' minute + interval '3' second as a_day from dual ;

select interval '100' day(3) + interval '12' minute + interval '3' second + current_timestamp as a_day from dual ;

-- Adding a DATE, the fractional part is lost
select to_timestamp(interval '100' day(3) + interval '12' minute + interval '3.122211' second + sysdate) as a_day from dual ;

select sysdate + interval '100' day(3) + interval '12' minute + interval '3.22222' second  as a_day from dual ;


--
select interval '99 00:00:00' day to second as x from dual ;
select interval '199 00:00:00' day(3) to second as x from dual ;

select interval '8-4' year to month as x from dual ;
select interval '-13-4' year to month as x from dual ;



/*
Large objects datatypes
----------------
BLOB
CLOB
NCLOB
BFILE
*/


