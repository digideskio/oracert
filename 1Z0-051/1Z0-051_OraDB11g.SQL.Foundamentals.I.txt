*****************************************************************
CHAPTER 1
*****************************************************************

Ch. 1.02 ~ Position the ServerTechnologies

Oracle DB is a 2 tier technology (client-server)
1) Client tier (creates SQL statements)
2) Server tier

Client tier is made by
1) a user (typically meaning a person)
2) a user process (client side application)

Server tier is made by
1) one or more Server Processes (that executes SQL statements)
2) one or more Database Instance (Oracle Instance)
3) a Database (Oracle DB)

a ** Server Process ** executes SQL
a ** Oracle Instance ** is a set of processes and memory structures that can be started and stopped and whose existence is temporary. Oracle instances manage access to the DB. It's not possible to direct access the DB without going through a Oracle Instance.

a ** Oracle Server ** is made by one or more Oracle Instances + a Oracle Database

for a **User process** on the client ther is a ** Server process ** on the server. The communications between user process and server process makes up a ** session **
Client tier and Server tier are phisically connected by a network. 
The communication protocol used by user and server prcesses is proprietary ** Oralce Net ** [protocol]

User processes and related server processes can be started or shut down on demand in order to create or terminate sessions.

Schema:
User -> User process -> Server Process -> Oracle Instance -> Oracle DB

Tools like SQL*Plus and SQL Developer can be considered ** user processes **

The simplest form of Oracle Database is made by ONE Oracle Instance accessing a Oracle Database.

In case of a Real Application Cluster (RAC) system, we'll have a Oracle Batabase opened by MANY Oracle Instances.
The ability to add dynamically more instances running on more nodes to a database is a major part of the database’s contribution to the Grid.


** The Oracle Application Server **
AS replaces client side software. It runs applications locally that are displayed to end users in their windows browsers. The application makes use of data in one or more ** Database Servers **
Applications written in Java should conform to the J2EE (Java 2 Enterprise Edition) standard, which defines how such applications should be packaged and deployed.




Ch. 1.02 ~ UNDERSTANDING RELATIONAL STRUCTURES

Table (aka entity / relation)
Row (aka record / tuple)
Column (aka attribute / field)

The number of rows in a table is also called "the cardinality of a tuple"


Data Normalization
------------------------
The process of modeling data into relational tables is known as normalization. There are commonly said to be three levels of normalization: the first, second, and third normal forms. There are higher levels of normalization: fourth and fifth normal forms are well defined, but any normal data analyst will not need to be concerned with them. It is possible for a SQL application to address un-normalized data, but this will usually be inefficient as that is not what the language is designed to do. In most cases, data stored in a relational database and accessed with SQL should be normalized to the third normal form.

Graphical conventions for primary and foreign key
primary keys (#)
foreign keys (\)
optional column (o)
mandatory column (*)

Ch. 1.03 ~ SQL Commands
These are the ** 16 SQL commands **, separated into commonly used groups:

The ** Data Manipulation Language (DML) ** commands:
	■ SELECT (*)
	■ INSERT
	■ UPDATE
	■ DELETE
	■ MERGE

(*) According to all the docs, SELECT is a DML statement. In practice, no one includes it when they refer to DML—they talk about it as though it were a language in its own right (it almost is) and use DML to mean only the commands that change data.

The ** Data Definition Language (DDL) ** commands:
	■ CREATE
	■ ALTER
	■ DROP
	■ RENAME
	■ TRUNCATE
	■ COMMENT

The ** Data Control Language (DCL) ** commands:
	■ GRANT
	■ REVOKE

The ** Transaction Control Language (TCL) ** commands:
	■ COMMIT
	■ ROLLBACK
	■ SAVEPOINT

DML (5 commands)
DDL (6 commands)
DCL (2 commands)
TCL (3 commands)


3GLs (procedural) languages manipulate rows one at the time.
SQL is a "set oriented" language meaning the action of one of its commands affects groups of rows in one statement. SQL is only able to access data, so it is not an application development language but is invoked by such languages when they need to access data.
Set oriented languages are more efficient then procedural languages as regard both development and execution.

Where SQL fails to provide a complete solution is that it is purely a data access language. Most applications will need procedural constructs, such as flow control: conditional branching and iteration. In this case PL/SQL gives the fetures SQL is missing.


====================================================
Ch. 1.04 ~ Client Tools
====================================================

SQL*Plus (on Linux)
-----------------------
Located in /u01/app/oracle/product/db_1/bin/sqlplus

There are some environment variables that will need to be set. These are
ORACLE_HOME			Oracle software installation: executables and configuration files
PATH 				must include the ORACLE_HOME directory
LD_LIBRARY_PATH		should include the `bin` directory in ORACLE_HOME (optional)

Connecting to SQL*Plus giving credentials
user/password@OracleNetID	is a Oracle Net Identifier


SQL*Plus (on Windows)
-----------------------
SQL*Plus historically had come in two flavours on Windows
	sqlplus.exe		is the character version
	sqlplusw.exe	was the graphical version (no longer shipped since 11g)

The /NOLOG switch (`sqlplus /nolog`) prevents the terminal from immediately presenting a login prompt (you'll need to run a `connect` command providing valid credentials to login.

The tests of the environment and the need to set the variables if they are not correct, previously described for a Linux installation, are not usually necessary on a Windows installation. This is because the variables are set in the Windows Registry by the Oracle Universal Installer when the software is installed. If SQL*Plus does not launch successfully, check the Registry variables
Check Windows regedit.exe
	HKEY_LOCAL_MACHINE
	SOFTWARE
	ORACLE
	KEY_OraDb11g_home1
Note the values of the Registry variables ORACLE_HOME and ORACLE_ HOME_NAME. These will relate to location of the sqlplus.exe executable and the Start menu navigation path to reach the shortcut that will launch it.


More on SQL*Plus
--------------------
sqlplus / as sysdba
	to connect to the DB as sysdba. It will work only if you are on the same machine where the Oralce Server is running


SQL> @?/demo/schema/human_resources/hr_main.sql
	"@" symbol will run a SQL script. The "?" character is a variable that SQL*Plus will expand to ORACHE_HOME
	On Windows it's teh same but back slashes are required @?\demo\schema\human_resources\hr_main.sql

show users
	lists all the users i the DB


Creating and Testing a Database Connection
-------------------------------------------
SQL*Plus does not have any way of storing database connection details. You must enter user/password each time.
SQL*Plus needs to know
	1. Who you are
	2. Where the database is
** Notice there are variations depending on site-specific security facilities **
There are 2 forms of connect identifier
	1. Using a Alias (requires the database administrator to configure a name resolution mechanism)
	2. entering the full details(requires the user to know all the details to connect the DB Server)

	sqlplus scott/tiger@orcl		(`orcl` is an alias)
	sqlplus scott/tiger@linsrv1.bplc.co.za:1521/orcl.bplc.com	(full details)

The usual techniques are to store this info in a local file named `tnsnames.ora` or to contact an LDAP directory.

The connection details nedded are
	1. host name of the machine on which the DB is running (linsrv1.bplc.co.za)
	2. TCP port on which the Oracle Net Listener can be contacted (1521)
	3. The database service to which the user wishes the database listener to connect him (orcl.bplc.com)

Common connection errors are:

	ORA-1254: TNS: could not resolve the connect identifier specified
	The given alias cannot be resolved into database connection details by the Transparent Network Substrate (TNS) that is a layer of Oracle Net. In this case the user gave a wrong alias.

	ORA-12541: TNS:no listener
	This indicates that the connect identifier has resolved correctly into the address of a database listener but
	A) the listener is not running
	B) the address resolution is faulty and is sending SQL*Plus to the wrong address

	ORA-12514: TNS:listener does not currently know of service requested in connect descriptor
	This error is generated by the database listener. SQL*Plus has found the listener with no problems, but the listener cannot make the onward connection to the database service. The most likely reason for this is that the database instance has not been started.

	ORA-01017: invalid username/password; logon denied
	Invalid credentials provided by the user (it can be either user or password or even both)
	Notice if you get this message you have connected the database


SQL Developer
---------------------
Graphical IDE written in Java require JRE
sqldeveloper.exe (WIN) / sqldeveloper.sh (Linux)

Main menu
■ File A normal Windows-like file menu, from which one can save work and exit from the tool.
■ Edit A normal Windows-like edit menu, from which one can undo, redo, copy, paste, find, and so on.
■ View The options for customizing the SQL Developer user interface.
■ Navigate Facilities for moving between panes and for moving around code
that is being edited.
■ Run Forces execution of the SQL statements, SQL script, or PL/SQL block that is being worked on.
■ Debug Rather than running a whole block of code, steps through it line by line with breakpoints.
■ Source Options for use when writing SQL and PL/SQL code, such as keyword completion and automatic indenting.
■ Tools Links to external programs, including SQL*Plus.
■ Migrate Tools for converting applications designed for third-party databases
(Microsoft Access, SQL Server, and MySQL) to the Oracle environment.
■ Help It’s pretty good.


========================================================
1.05 ~ Create the Demonstration Schemas
========================================================

Users and Schemas
-----------------
a ** user ** is a person who can login to the Database, a ** schema ** is the set of objects owned by a user. The two terms can often be used interchangeably, as there is a one-to-one relationship between users and schemas.
Note that while there is in fact a CREATE SCHEMA command, this does not actually create a schema, it is only a quick way of creating objects in a schema. 

*** NOTICE ***
A schema is initially created empty, when a user is created with the CREATE USER command.

The unique identifier for any schema object is the username, followed by the object name (USER.OBJECT). Objects with the same name cannot reside in the same schema but they can resides in different schemas. For accessing a object from ina different schema is necessary to use the unique identifier.

** WARNING **
The demonstration schemas should not exist in production databases. It is not good, for security reasons, to have unnecessary schemas in a database that have well known usernames, capabilities, and (possibly) passwords.
** WARNING **


========================================================
SELF TEST
========================================================

Question 9

Where may the demonstration schemas be created? (Choose the best answer.)
A. The demonstration schemas must be created in a demonstration database.
B. The demonstration schemas cannot be created in a production database.
C. The demonstration schemas can be created in any database.
D. The demonstration schemas can be created in any database if the demonstration user is created first.

Answer 9

✓ C. The demonstration schemas can be created in any database, either at database creation time or by running scripts later.
x A, B, D. A and B are wrong because, while they may be good practice, they are not a technical requirement. D is wrong because it fails to understand that a schema can only be (and always is) created with a user.


*****************************************************************
CHAPTER 2
*****************************************************************

table data are the data containd in table rows.
table metadata are information about a table structure, size, ecc... containd in the * data dictionary *

DESC[RIBE] <SCHEMA>.tablename

all schemas have access to a special table called DUAL, which belongs to the SYS schema. This table can be structurally described with the command: DESCRIBE SYS.DUAL


DATA TYPES
--------------------
NUMBER(p,s) precision, scale
This means that the values stored in this column can have at most "p" digits. Of these "p" digits, "s" must be to the right of the decimal point.

	Number(8,2)
	 999999.99	OK	(6+2)
	 999999.9 	OK	(6+1)
	9999999.9 	KO	(7+1)

VARCHAR2(length) variable length alphanumeric character data (up to "length")

	VARCHAR2(20)
	means it can store employees’ names of up to 20 characters

CHAR(size) fixed-length columns where row space is preallocated to contain a fixed number of characters regardless
of its contents (inefficient for storage)

DATE
stores a moment in time with precision including day, month, year, hours, minutes, and seconds

TIMESTAMP(f)
same as DATE but is capable of storinf fractional seconds

BLOB (Binary Large Object)

CLOB (Character Large Object)

NULL meand "No Data". blank spaces DO NOT count as NULL since they're present inthe row.

Capabilities of the SELECT Statement
-------------------------------------
Relational database tables are built on a strong mathematical foundation called relational theory. In this theory, relations, or tables, are operated on by a formal language called relational algebra. SQL is a commercial interpretation of the relational algebraic constructs. Three concepts from relational theory encompass the capability of the SELECT statement: projection, selection, and joining.

	Projection: refers to the restriction of attributes (columns) selected from a relation or table.
	Selection: refers to the restriction of the tuples or rows selected from a relation (table).
	Joining: refers to the interaction of tables with each other in a query.

In its most primitive form, the SELECT statement supports the projection of columns and the creation of arithmetic, character, and date expressions. It also facilitates the elimination of duplicate values from the results set.

	SELECT *|{[DISTINCT] column|expression [alias],...}
	  FROM table;

Use of the asterisk in a SELECT statement is sometimes referred to as a “blind” query because the exact columns to be fetched are not specified.

Be careful, though, when using blind queries to select data from large tables. Executing a SELECT * FROM HUGE_TABLE; statement may cause performance issues if the table contains millions of rows of data.

SQL*Plus always requires a statement terminator, and usually a semicolon is used. Individual statements in SQL scripts are commonly terminated by a line break and a forward slash on the next line, instead of a semicolon. You can create a SELECT statement, terminate it with a line break, include a forward slash to execute the statement, and save it in a script file. The script file can then be called from within SQL*Plus.


Arithmetic operations precedence
--------------------------------------

If more than one operator with the same level of precedence is present in an expression, then these will be evaluated from left to right.

Precedence level	Operator symbol		Operation
Highest				()					Brackets or parentheses
Medium				/					Division
Medium				∗					Multiplication
Lowest				−					Subtraction
Lowest				+					Addition

Example
region_id * 100/5 + 20 / 10 − 5		region_id * 100/5 + 20 / (10 − 5)
3 * 100 /5 + 20 / 10 − 5			3 * 100 / 5 + 20 / (10 − 5)
300 / 5 + 20 / 10 − 5				3*100/5 + 20/5
60 + 20/10 − 5						300/5 + 20/5
60 + 2 − 5							60 + 20/5
62 − 5=57							60 + 4 = 64


Column aliasing
--------------------
Enclosing a alias in double quotes (") makes possible to
	use spaces in alias name (multi-worded alias)
	preserve case sensitivity
typing a alias like mYalIAs will be displayed as MYALIAS when not enclosed in double quotes
Notie also aliases may be precedeed by the keyword `AS` that improves readability.

	Select column_name [AS] alias
	Select column_name [AS] aLiAS
	Select column_name [AS] "aLiAS"
	Select column_name [AS] "my aLiAS"

NOTICE:
Failure to double quote a multiworded alias will raise an Oracle error. 
Failure to double quote a single-word alias will result in the alias being returned in uppercase.


DATA TYPES
-----------
The data types of the columns being queried determine how SQL*Plus and SQL Developer present their default data outputs. 
	numeric		the column data is formatted to be RIGHT aligned
	character	the column data is formatted to be LEFT aligned.
	date		the column data is formatted to be LEFT aligned.


Literals and the DUAL Table
---------------------------
Oracle chose the single quote characters as the special pair of symbols that enclose or wrap any other character literal. In case you need to write a quote ina string literal, you have two options:
	1. doubling the single quotes in your string
	2. uning the `alternative quote` operator q'delim' delim can be any single-byte or multibyte character or the four brackets: (round brackets), {curly braces}, [square brackets], or <angle brackets>


	select 'Plural's have one quote too many' from dual;	ERROR
	select 'Plural''s have one quote too many' from dual;	OK (doubling)

	SQL> select q'<'Plural's can also be specified with alternate quote operators>' AS "q<>" from dual ;

	q<>
	--------------------------------------------------------------
	'Plural's can also be specified with alternate quote operators

	1 row selected


	SQL> select q'['Even square brackets' [] can also be used for Plural's]' AS "q[]" from dual ;

	q[]
	-------------------------------------------------------
	'Even square brackets' [] can also be used for Plural's

	1 row selected
	

	SQL> select q'X'What about UPPER CASE X' Plural'sX' AS "qX" from dual ;

	qX
	----------------------------------
	'What about UPPER CASE X' Plural's

	1 row selected


NULL Is Nothing
----------------
Both the number zero and a blank space are different from null since they occupy space. NULL refers to an absence of data. A row that contains a null value lacks data for that column. Null is formally defined as a value that is unavailable, unassigned, unknown, or inapplicable. The rules of engaging with null values need careful examination. Null is a placeholder in a nonmandatory column until some real data is stored in its place.

Any ** arithmetic calculation ** with a NULL value always returns NULL. Even division by a null value results in null, unlike division by zero, which results in an error.

The character concatenation operators ignore null. 

	SQL> Select 'A' || NULL || 'B' from dual as "NullConcat";

	NullConcat
	----------
	AB

	1 row selected

Foreign Keys and Nullable Columns
---------------------------------
Can the DEPARTMENT_ID column in the DEPARTMENTS table contain nulls? The answer is no. Oracle insists that any column that is a primary key is implicitly constrained to be mandatory.
But what about implicit constraints on foreign key columns? This is a quandary for Oracle, since in order to remain flexible and cater to the widest audience, it cannot insist that columns related through referential integrity constraints must be mandatory. Further, not all situations demand this functionality.



*****************************************************************
CHAPTER 3 - Restrictions (WHERE clause)
*****************************************************************

DATE format: a literal with this format '01-JAN-88' implicitly uses "RR" year 2000 compliant -> if it is between 50 and 99, will return the previous century, otherwise the current one.
'01-JAN-01' -> 01-JAN-2001
'01-JAN-99' -> 01-JAN-1999
'01-JAN-50' -> 01-JAN-1950
'01-JAN-49' -> 01-JAN-2049

"YY" always refer to the current century

  /* 1950/2050 */
  select to_char(to_date('01-JAN-50','DD-MON-RR'),'YYYY-MM-DD') as RR
       , to_char(to_date('01-JAN-50','DD-MON-YY'),'YYYY-MM-DD') as YY
  from dual;
  
  /* 1999/2099 */
  select to_char(to_date('01-JAN-99','DD-MON-RR'),'YYYY-MM-DD') as RR
       , to_char(to_date('01-JAN-99','DD-MON-YY'),'YYYY-MM-DD') as YY
  from dual;
  
  /* 2012/2012 */
  select to_char(to_date('01-JAN-12','DD-MON-RR'),'YYYY-MM-DD') as RR
       , to_char(to_date('01-JAN-12','DD-MON-YY'),'YYYY-MM-DD') as YY
  from dual;

Comparison
------------------
Equality	=			equals
Inequality	!=			NOT equals
Inequality	<>			NOT equals
Inequality	>			greather then
Inequality	<			less then
Inequality	>=			greather then or equal to
Inequality	<=			less then or equal to
Range		in ()		in a given set 
Between		between and	enclosed in a given range (including range limits)
IS NULL		IS NULL
			LIKE		pattern matching

Comparison in CHARS
-------------------------
Numeric ineqiality is intuitive. The comparison of characters and date is more complex.
In character comparison all the characters on both sides are converted in to a numeric representation based on
1. the DB character set
2. the National Language Support (NLS) settings

SELECT last_name FROM employees WHERE last_name < 'King';

K+i+n+g = 75+105+110+103 = 393

For each row in the employee table the value in last_name is similarly coverted and all columns whose value is less then 393 are selected.

Comparing number and characters on Oracle inolve the same process. The only difference is that characters are implicitly converted to numeric values depending on some database settings.

Inequality comparison on DATEs follow a simila process. Oracle stores dates internally in a numeric format.

SELECT last_name 
  FROM employees
 WHERE hire_date < '01-JAN-2000';

a LITERAL is value of any type
1.  8
2.  'hello'
4.  '20-JAN-2011'
5.  763.762

BETWEEN operator  [ column BETWEEN lower AND upper ]
1. it's equivalent to a ( column >= lower AND column <= upper )
2. Operands can be 
    - literal values
    - column values
    - expression

IN operator   [ column IN (v1, v2, v3, .., vN) ]
1. it's equivalent to a series of `OR` conditions: (column = v1 OR column = v2 OR .. OR column = vN)
2. there's no limit to elements in the set


LIKE operator  [ column LIKE '%abc_e%' ]
1. pattern matching on characters
2. wildcards represent any character
3. % wildcard means zero or more characters
4. _ wildcard means one character
5. column LIKE '%' returns every NOT NULL column value
6. Pattern matching wouldn't be possible without the wildcards symbols
7. wildcards canbe mixed and use multiple times in the same pattern
8. column LIKE 'SA\_%' escape '\'  or even  column LIKE 'SA$_%' escape '$'
9. works on NUMERIC data through implicit cast (if possible): WHERE salary LIKE '%80%'

IS NULL operator [ column IS NULL ]
1.

Boolean operators
-----------------
AND ( x AND y )
If two conditions are joined wit a AND operator then a row is tested consequtively for conformance to both conditions before being retrieved.
The more AND conditions you add, the more restrictive your query becomes.

AND truth table
X	Y	Result
F	F	FALSE
F	T	FALSE
F	N	NULL
T	F	FALSE
T	T	TRUE
T	N	NULL
N	F	NULL
N	T	NULL
N	N	NULL


OR ( x OR y )
If two conditions are joined wit a OR operator then a row is tested consequtively for conformance to either or both conditions before being retrieved.
The more OR conditions you add, the less restrictive your query becomes.

NOT ( NOT x)
truth table:
True False
False true
NULL NULL

Boolean operators precedence rules
----------------------------------

AND take precedence on OR
NOT just nagate the result so it is neutral to precedence rules

Order by clause
---------------
is always the last clause in a SELECT statement

ORDER BY {cols(s) | expr | numeric_pos} [ASC|DESC] [NULL FIRST| LAST]

default is ASCENDING 
on ASCENDING  > default is NULL LAST
on DESCENDING > default is NULL FIRST

When "order by" is not specified, the same rows are returned in random order and the order may change running the same query at different times.

Positional sorting uses the position of the column (from left to right) instead of the column name.

composite sorting is possible specifying columns mixing column name and position

select job_id, last_name, salary, hire_date
  from employees
 where job_id in ('SA_REP','MK_MAN')
 order by job_id, desc, last_name, 3 desc ;

It is also possible to specify a ** alias instad of the column name **.

AMPERSAND SUBSTITUTION
----------------------
*EVERY* element in a SELECT statement may be subsituted to facilitate reuse.

Substitution variables
----------------------
they are placeholders.

&variable (must be enclosed in single quotes foe character and dates '&variable')

Oracle Server
- processes teh statment
- notices a substitution variable
- attempts to resolve the substitution variables in 2 ways:
	1. First, checks if the variable is defined in the user session (see DEFINE)
	2. if not defined, the user process prompts for a value to be entered for substitution
- once the value is submitted, the statement is complete and is executed.

being resolved at runtime, "ampersand substitution" is also known as "runtime substitution" or "runtime binding"

NOTICE the differences:

SELECT employee_id
  from EMPLOYEES
 where last_name = &LASTNAME ;  // enter 'King' at prompt for substitution
    
SELECT employee_id
  from EMPLOYEES
 where last_name = '&LASTNAME' ;  // enter King at prompt for substitution

DOUBLE AMPERSAND SUBSTITUTION
-----------------------------

select first_name, last_name
from employees
where last_name like '%&SEARCH%'
  or first_name like '%&SEARCH%'

In this query you'll be promped twice for entering the same variable. This in inefficient:
1. typografical error would make the search criteria different
2. Oracle does not verify the values you entered are the same

when a variable occoures more then once in your SQL script, you may use the ** DOUBLE AMPERSAND SUBSTITUTION **
When Oracle Server encounters a double ampersand variable, a session value is defined for that variable and you are not promped to re-enter the value in subsequent occurrences. All subsequent run of the script woun't require to re-enter the values because they will be taken from the session.
To remove the variable from session, you must use the UNDEFINE command .

Queries with ampersand substitution may potentially benefit from Oracle automatic tuning.

Select &&a, &&a FROM DUAL; // prompts once
Select &&b,  &b FROM DUAL; // prompts once
Select  &c, &&c FROM DUAL; // prompts twice

It is also possible to use ampersand substitution in **column substitution**

substituting expressions and text
Almost any element may be substituted at runtime. The constraint is that Oracle requires at leas the firs word to be static.

SELECT &rest_of_statement ;

Session variables are created when they are initially referenced in SQL statements using DOUBLE AMPERSAND SUBSTITUTION. It won't happen using (SINGLE) AMPERSAND SUBSTITUTION. They'll exist untile the end of the session or untile they are UNDEFINED.

UNDEFINE variable;

DEFINE;		// lists all the session variables
DEFINE variable=value;	// creates a session variable named "variable" containing "value"

in SQL*Plus there are predefined variables prefixed with underscore (_). this is NOT a special character. You can define your variables prefixed with underscore.

Ampersand substitution may be disabled or anabled in SQL*Plus

SET define off
Select 'Coda & SID' from dual ;
SET define on

