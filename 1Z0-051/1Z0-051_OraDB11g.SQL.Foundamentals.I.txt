*****************************************************************
CHAPTER 1
*****************************************************************

Ch. 1.02 ~ Position the ServerTechnologies

Oracle DB is a 2 tier technology (client-server)
1) Client tier (creates SQL statements)
2) Server tier

Client tier is made by
1) a user (typically meaning a person)
2) a user process (client side application)

Server tier is made by
1) one or more Server Processes (that executes SQL statements)
2) one or more Database Instance (Oracle Instance)
3) a Database (Oracle DB)

a ** Server Process ** executes SQL
a ** Oracle Instance ** is a set of processes and memory structures that can be started and stopped and whose existence is temporary. Oracle instances manage access to the DB. It's not possible to direct access the DB without going through a Oracle Instance.

a ** Oracle Server ** is made by one or more Oracle Instances + a Oracle Database

for a **User process** on the client ther is a ** Server process ** on the server. The communications between user process and server process makes up a ** session **
Client tier and Server tier are phisically connected by a network. 
The communication protocol used by user and server prcesses is proprietary ** Oralce Net ** [protocol]

User processes and related server processes can be started or shut down on demand in order to create or terminate sessions.

Schema:
User -> User process -> Server Process -> Oracle Instance -> Oracle DB

Tools like SQL*Plus and SQL Developer can be considered ** user processes **

The simplest form of Oracle Database is made by ONE Oracle Instance accessing a Oracle Database.

In case of a Real Application Cluster (RAC) system, we'll have a Oracle Batabase opened by MANY Oracle Instances.
The ability to add dynamically more instances running on more nodes to a database is a major part of the database’s contribution to the Grid.


** The Oracle Application Server **
AS replaces client side software. It runs applications locally that are displayed to end users in their windows browsers. The application makes use of data in one or more ** Database Servers **
Applications written in Java should conform to the J2EE (Java 2 Enterprise Edition) standard, which defines how such applications should be packaged and deployed.




Ch. 1.02 ~ UNDERSTANDING RELATIONAL STRUCTURES

Table (aka entity / relation)
Row (aka record / tuple)
Column (aka attribute / field)

The number of rows in a table is also called "the cardinality of a tuple"


Data Normalization
------------------------
The process of modeling data into relational tables is known as normalization. There are commonly said to be three levels of normalization: the first, second, and third normal forms. There are higher levels of normalization: fourth and fifth normal forms are well defined, but any normal data analyst will not need to be concerned with them. It is possible for a SQL application to address un-normalized data, but this will usually be inefficient as that is not what the language is designed to do. In most cases, data stored in a relational database and accessed with SQL should be normalized to the third normal form.

Graphical conventions for primary and foreign key
primary keys (#)
foreign keys (\)
optional column (o)
mandatory column (*)

Ch. 1.03 ~ SQL Commands
These are the ** 16 SQL commands **, separated into commonly used groups:

The ** Data Manipulation Language (DML) ** commands:
	■ SELECT (*)
	■ INSERT
	■ UPDATE
	■ DELETE
	■ MERGE

(*) According to all the docs, SELECT is a DML statement. In practice, no one includes it when they refer to DML—they talk about it as though it were a language in its own right (it almost is) and use DML to mean only the commands that change data.

The ** Data Definition Language (DDL) ** commands:
	■ CREATE
	■ ALTER
	■ DROP
	■ RENAME
	■ TRUNCATE
	■ COMMENT

The ** Data Control Language (DCL) ** commands:
	■ GRANT
	■ REVOKE

The ** Transaction Control Language (TCL) ** commands:
	■ COMMIT
	■ ROLLBACK
	■ SAVEPOINT

DML (5 commands)
DDL (6 commands)
DCL (2 commands)
TCL (3 commands)


3GLs (procedural) languages manipulate rows one at the time.
SQL is a "set oriented" language meaning the action of one of its commands affects groups of rows in one statement. SQL is only able to access data, so it is not an application development language but is invoked by such languages when they need to access data.
Set oriented languages are more efficient then procedural languages as regard both development and execution.

Where SQL fails to provide a complete solution is that it is purely a data access language. Most applications will need procedural constructs, such as flow control: conditional branching and iteration. In this case PL/SQL gives the fetures SQL is missing.


====================================================
Ch. 1.04 ~ Client Tools
====================================================

SQL*Plus (on Linux)
-----------------------
Located in /u01/app/oracle/product/db_1/bin/sqlplus

There are some environment variables that will need to be set. These are
ORACLE_HOME			Oracle software installation: executables and configuration files
PATH 				must include the ORACLE_HOME directory
LD_LIBRARY_PATH		should include the `bin` directory in ORACLE_HOME (optional)

Connecting to SQL*Plus giving credentials
user/password@OracleNetID	is a Oracle Net Identifier


SQL*Plus (on Windows)
-----------------------
SQL*Plus historically had come in two flavours on Windows
	sqlplus.exe		is the character version
	sqlplusw.exe	was the graphical version (no longer shipped since 11g)

The /NOLOG switch (`sqlplus /nolog`) prevents the terminal from immediately presenting a login prompt (you'll need to run a `connect` command providing valid credentials to login.

The tests of the environment and the need to set the variables if they are not correct, previously described for a Linux installation, are not usually necessary on a Windows installation. This is because the variables are set in the Windows Registry by the Oracle Universal Installer when the software is installed. If SQL*Plus does not launch successfully, check the Registry variables
Check Windows regedit.exe
	HKEY_LOCAL_MACHINE
	SOFTWARE
	ORACLE
	KEY_OraDb11g_home1
Note the values of the Registry variables ORACLE_HOME and ORACLE_ HOME_NAME. These will relate to location of the sqlplus.exe executable and the Start menu navigation path to reach the shortcut that will launch it.


More on SQL*Plus
--------------------
sqlplus / as sysdba
	to connect to the DB as sysdba. It will work only if you are on the same machine where the Oralce Server is running


SQL> @?/demo/schema/human_resources/hr_main.sql
	"@" symbol will run a SQL script. The "?" character is a variable that SQL*Plus will expand to ORACHE_HOME
	On Windows it's teh same but back slashes are required @?\demo\schema\human_resources\hr_main.sql

show users
	lists all the users i the DB


Creating and Testing a Database Connection
-------------------------------------------
SQL*Plus does not have any way of storing database connection details. You must enter user/password each time.
SQL*Plus needs to know
	1. Who you are
	2. Where the database is
** Notice there are variations depending on site-specific security facilities **
There are 2 forms of connect identifier
	1. Using a Alias (requires the database administrator to configure a name resolution mechanism)
	2. entering the full details(requires the user to know all the details to connect the DB Server)

	sqlplus scott/tiger@orcl		(`orcl` is an alias)
	sqlplus scott/tiger@linsrv1.bplc.co.za:1521/orcl.bplc.com	(full details)

The usual techniques are to store this info in a local file named `tnsnames.ora` or to contact an LDAP directory.

The connection details nedded are
	1. host name of the machine on which the DB is running (linsrv1.bplc.co.za)
	2. TCP port on which the Oracle Net Listener can be contacted (1521)
	3. The database service to which the user wishes the database listener to connect him (orcl.bplc.com)

Common connection errors are:

	ORA-1254: TNS: could not resolve the connect identifier specified
	The given alias cannot be resolved into database connection details by the Transparent Network Substrate (TNS) that is a layer of Oracle Net. In this case the user gave a wrong alias.

	ORA-12541: TNS:no listener
	This indicates that the connect identifier has resolved correctly into the address of a database listener but
	A) the listener is not running
	B) the address resolution is faulty and is sending SQL*Plus to the wrong address

	ORA-12514: TNS:listener does not currently know of service requested in connect descriptor
	This error is generated by the database listener. SQL*Plus has found the listener with no problems, but the listener cannot make the onward connection to the database service. The most likely reason for this is that the database instance has not been started.

	ORA-01017: invalid username/password; logon denied
	Invalid credentials provided by the user (it can be either user or password or even both)
	Notice if you get this message you have connected the database


SQL Developer
---------------------
Graphical IDE written in Java require JRE
sqldeveloper.exe (WIN) / sqldeveloper.sh (Linux)

Main menu
■ File A normal Windows-like file menu, from which one can save work and exit from the tool.
■ Edit A normal Windows-like edit menu, from which one can undo, redo, copy, paste, find, and so on.
■ View The options for customizing the SQL Developer user interface.
■ Navigate Facilities for moving between panes and for moving around code
that is being edited.
■ Run Forces execution of the SQL statements, SQL script, or PL/SQL block that is being worked on.
■ Debug Rather than running a whole block of code, steps through it line by line with breakpoints.
■ Source Options for use when writing SQL and PL/SQL code, such as keyword completion and automatic indenting.
■ Tools Links to external programs, including SQL*Plus.
■ Migrate Tools for converting applications designed for third-party databases
(Microsoft Access, SQL Server, and MySQL) to the Oracle environment.
■ Help It’s pretty good.


========================================================
1.05 ~ Create the Demonstration Schemas
========================================================

Users and Schemas
-----------------
a ** user ** is a person who can login to the Database, a ** schema ** is the set of objects owned by a user. The two terms can often be used interchangeably, as there is a one-to-one relationship between users and schemas.
Note that while there is in fact a CREATE SCHEMA command, this does not actually create a schema, it is only a quick way of creating objects in a schema. 

*** NOTICE ***
A schema is initially created empty, when a user is created with the CREATE USER command.

The unique identifier for any schema object is the username, followed by the object name (USER.OBJECT). Objects with the same name cannot reside in the same schema but they can resides in different schemas. For accessing a object from ina different schema is necessary to use the unique identifier.

** WARNING **
The demonstration schemas should not exist in production databases. It is not good, for security reasons, to have unnecessary schemas in a database that have well known usernames, capabilities, and (possibly) passwords.
** WARNING **


========================================================
SELF TEST
========================================================

Question 9

Where may the demonstration schemas be created? (Choose the best answer.)
A. The demonstration schemas must be created in a demonstration database.
B. The demonstration schemas cannot be created in a production database.
C. The demonstration schemas can be created in any database.
D. The demonstration schemas can be created in any database if the demonstration user is created first.

Answer 9

✓ C. The demonstration schemas can be created in any database, either at database creation time or by running scripts later.
x A, B, D. A and B are wrong because, while they may be good practice, they are not a technical requirement. D is wrong because it fails to understand that a schema can only be (and always is) created with a user.


*****************************************************************
CHAPTER 2
*****************************************************************

table data are the data containd in table rows.
table metadata are information about a table structure, size, ecc... containd in the * data dictionary *

DESC[RIBE] <SCHEMA>.tablename

all schemas have access to a special table called DUAL, which belongs to the SYS schema. This table can be structurally described with the command: DESCRIBE SYS.DUAL


DATA TYPES
--------------------
NUMBER(p,s) precision, scale
This means that the values stored in this column can have at most "p" digits. Of these "p" digits, "s" must be to the right of the decimal point.

	Number(8,2)
	 999999.99	OK	(6+2)
	 999999.9 	OK	(6+1)
	9999999.9 	KO	(7+1)

VARCHAR2(length) variable length alphanumeric character data (up to "length")

	VARCHAR2(20)
	means it can store employees’ names of up to 20 characters

CHAR(size) fixed-length columns where row space is preallocated to contain a fixed number of characters regardless
of its contents (inefficient for storage)

DATE
stores a moment in time with precision including day, month, year, hours, minutes, and seconds

TIMESTAMP(f)
same as DATE but is capable of storinf fractional seconds

BLOB (Binary Large Object)

CLOB (Character Large Object)

NULL meand "No Data". blank spaces DO NOT count as NULL since they're present inthe row.

Capabilities of the SELECT Statement
-------------------------------------
Relational database tables are built on a strong mathematical foundation called relational theory. In this theory, relations, or tables, are operated on by a formal language called relational algebra. SQL is a commercial interpretation of the relational algebraic constructs. Three concepts from relational theory encompass the capability of the SELECT statement: projection, selection, and joining.

	Projection: refers to the restriction of attributes (columns) selected from a relation or table.
	Selection: refers to the restriction of the tuples or rows selected from a relation (table).
	Joining: refers to the interaction of tables with each other in a query.

In its most primitive form, the SELECT statement supports the projection of columns and the creation of arithmetic, character, and date expressions. It also facilitates the elimination of duplicate values from the results set.

	SELECT *|{[DISTINCT] column|expression [alias],...}
	  FROM table;

Use of the asterisk in a SELECT statement is sometimes referred to as a “blind” query because the exact columns to be fetched are not specified.

Be careful, though, when using blind queries to select data from large tables. Executing a SELECT * FROM HUGE_TABLE; statement may cause performance issues if the table contains millions of rows of data.

SQL*Plus always requires a statement terminator, and usually a semicolon is used. Individual statements in SQL scripts are commonly terminated by a line break and a forward slash on the next line, instead of a semicolon. You can create a SELECT statement, terminate it with a line break, include a forward slash to execute the statement, and save it in a script file. The script file can then be called from within SQL*Plus.


Arithmetic operations precedence
--------------------------------------

If more than one operator with the same level of precedence is present in an expression, then these will be evaluated from left to right.

Precedence level	Operator symbol		Operation
Highest				()					Brackets or parentheses
Medium				/					Division
Medium				∗					Multiplication
Lowest				−					Subtraction
Lowest				+					Addition

Example
region_id * 100/5 + 20 / 10 − 5		region_id * 100/5 + 20 / (10 − 5)
3 * 100 /5 + 20 / 10 − 5			3 * 100 / 5 + 20 / (10 − 5)
300 / 5 + 20 / 10 − 5				3*100/5 + 20/5
60 + 20/10 − 5						300/5 + 20/5
60 + 2 − 5							60 + 20/5
62 − 5=57							60 + 4 = 64


Column aliasing
--------------------
Enclosing a alias in double quotes (") makes possible to
	use spaces in alias name (multi-worded alias)
	preserve case sensitivity
typing a alias like mYalIAs will be displayed as MYALIAS when not enclosed in double quotes
Notie also aliases may be precedeed by the keyword `AS` that improves readability.

	Select column_name [AS] alias
	Select column_name [AS] aLiAS
	Select column_name [AS] "aLiAS"
	Select column_name [AS] "my aLiAS"

NOTICE:
Failure to double quote a multiworded alias will raise an Oracle error. 
Failure to double quote a single-word alias will result in the alias being returned in uppercase.


DATA TYPES
-----------
The data types of the columns being queried determine how SQL*Plus and SQL Developer present their default data outputs. 
	numeric		the column data is formatted to be RIGHT aligned
	character	the column data is formatted to be LEFT aligned.
	date		the column data is formatted to be LEFT aligned.


Literals and the DUAL Table
---------------------------
Oracle chose the single quote characters as the special pair of symbols that enclose or wrap any other character literal. In case you need to write a quote ina string literal, you have two options:
	1. doubling the single quotes in your string
	2. uning the `alternative quote` operator q'delim' delim can be any single-byte or multibyte character or the four brackets: (round brackets), {curly braces}, [square brackets], or <angle brackets>


	select 'Plural's have one quote too many' from dual;	ERROR
	select 'Plural''s have one quote too many' from dual;	OK (doubling)

	SQL> select q'<'Plural's can also be specified with alternate quote operators>' AS "q<>" from dual ;

	q<>
	--------------------------------------------------------------
	'Plural's can also be specified with alternate quote operators

	1 row selected


	SQL> select q'['Even square brackets' [] can also be used for Plural's]' AS "q[]" from dual ;

	q[]
	-------------------------------------------------------
	'Even square brackets' [] can also be used for Plural's

	1 row selected
	

	SQL> select q'X'What about UPPER CASE X' Plural'sX' AS "qX" from dual ;

	qX
	----------------------------------
	'What about UPPER CASE X' Plural's

	1 row selected


NULL Is Nothing
----------------
Both the number zero and a blank space are different from null since they occupy space. NULL refers to an absence of data. A row that contains a null value lacks data for that column. Null is formally defined as a value that is unavailable, unassigned, unknown, or inapplicable. The rules of engaging with null values need careful examination. Null is a placeholder in a nonmandatory column until some real data is stored in its place.

Any ** arithmetic calculation ** with a NULL value always returns NULL. Even division by a null value results in null, unlike division by zero, which results in an error.

The character concatenation operators ignore null. 

	SQL> Select 'A' || NULL || 'B' from dual as "NullConcat";

	NullConcat
	----------
	AB

	1 row selected

Foreign Keys and Nullable Columns
---------------------------------
Can the DEPARTMENT_ID column in the DEPARTMENTS table contain nulls? The answer is no. Oracle insists that any column that is a primary key is implicitly constrained to be mandatory.
But what about implicit constraints on foreign key columns? This is a quandary for Oracle, since in order to remain flexible and cater to the widest audience, it cannot insist that columns related through referential integrity constraints must be mandatory. Further, not all situations demand this functionality.



*****************************************************************
CHAPTER 3 - Restrictions (WHERE clause)
*****************************************************************

DATE format: a literal with this format '01-JAN-88' implicitly uses "RR" year 2000 compliant -> if it is between 50 and 99, will return the previous century, otherwise the current one.

00-49  /  50-99 

'01-JAN-01' -> 01-JAN-2001
'01-JAN-99' -> 01-JAN-1999
'01-JAN-50' -> 01-JAN-1950
'01-JAN-49' -> 01-JAN-2049

"YY" always refer to the current century

  /* 1950/2050 */
  select to_char(to_date('01-JAN-50','DD-MON-RR'),'YYYY-MM-DD') as RR
       , to_char(to_date('01-JAN-50','DD-MON-YY'),'YYYY-MM-DD') as YY
  from dual;
  
  /* 1999/2099 */
  select to_char(to_date('01-JAN-99','DD-MON-RR'),'YYYY-MM-DD') as RR
       , to_char(to_date('01-JAN-99','DD-MON-YY'),'YYYY-MM-DD') as YY
  from dual;
  
  /* 2012/2012 */
  select to_char(to_date('01-JAN-12','DD-MON-RR'),'YYYY-MM-DD') as RR
       , to_char(to_date('01-JAN-12','DD-MON-YY'),'YYYY-MM-DD') as YY
  from dual;

Comparison
------------------
Equality	=			equals
Inequality	!=			NOT equals
Inequality	<>			NOT equals
Inequality	>			greather then
Inequality	<			less then
Inequality	>=			greather then or equal to
Inequality	<=			less then or equal to
Range		in ()		in a given set 
Between		between and	enclosed in a given range (including range limits)
IS NULL		IS NULL
			LIKE		pattern matching

Comparison in CHARS
-------------------------
Numeric ineqiality is intuitive. The comparison of characters and date is more complex.
In character comparison all the characters on both sides are converted in to a numeric representation based on
1. the DB character set
2. the National Language Support (NLS) settings

SELECT last_name FROM employees WHERE last_name < 'King';

K+i+n+g = 75+105+110+103 = 393

For each row in the employee table the value in last_name is similarly coverted and all columns whose value is less then 393 are selected.

Comparing number and characters on Oracle inolve the same process. The only difference is that characters are implicitly converted to numeric values depending on some database settings.

Inequality comparison on DATEs follow a simila process. Oracle stores dates internally in a numeric format.

SELECT last_name 
  FROM employees
 WHERE hire_date < '01-JAN-2000';

a LITERAL is value of any type
1.  8
2.  'hello'
4.  '20-JAN-2011'
5.  763.762

BETWEEN operator  [ column BETWEEN lower AND upper ]
1. it's equivalent to a ( column >= lower AND column <= upper )
2. Operands can be 
    - literal values
    - column values
    - expression

IN operator   [ column IN (v1, v2, v3, .., vN) ]
1. it's equivalent to a series of `OR` conditions: (column = v1 OR column = v2 OR .. OR column = vN)
2. there's no limit to elements in the set


LIKE operator  [ column LIKE '%abc_e%' ]
1. pattern matching on characters
2. wildcards represent any character
3. % wildcard means zero or more characters
4. _ wildcard means one character
5. column LIKE '%' returns every NOT NULL column value
6. Pattern matching wouldn't be possible without the wildcards symbols
7. wildcards canbe mixed and use multiple times in the same pattern
8. column LIKE 'SA\_%' escape '\'  or even  column LIKE 'SA$_%' escape '$'
9. works on NUMERIC data through implicit cast (if possible): WHERE salary LIKE '%80%'

IS NULL operator [ column IS NULL ]
1.

Boolean operators
-----------------
AND ( x AND y )
If two conditions are joined wit a AND operator then a row is tested consequtively for conformance to both conditions before being retrieved.
The more AND conditions you add, the more restrictive your query becomes.

AND truth table
X	Y	Result
F	F	FALSE
F	T	FALSE
F	N	NULL
T	F	FALSE
T	T	TRUE
T	N	NULL
N	F	NULL
N	T	NULL
N	N	NULL


OR ( x OR y )
If two conditions are joined wit a OR operator then a row is tested consequtively for conformance to either or both conditions before being retrieved.
The more OR conditions you add, the less restrictive your query becomes.

NOT ( NOT x)
truth table:
True False
False true
NULL NULL

Boolean operators precedence rules
----------------------------------

AND take precedence on OR
NOT just nagate the result so it is neutral to precedence rules

Order by clause
---------------
is always the last clause in a SELECT statement

ORDER BY {cols(s) | expr | numeric_pos} [ASC|DESC] [NULL FIRST| LAST]

default is ASCENDING 
on ASCENDING  > default is NULL LAST
on DESCENDING > default is NULL FIRST

When "order by" is not specified, the same rows are returned in random order and the order may change running the same query at different times.

Positional sorting uses the position of the column (from left to right) instead of the column name.

composite sorting is possible specifying columns mixing column name and position

select job_id, last_name, salary, hire_date
  from employees
 where job_id in ('SA_REP','MK_MAN')
 order by job_id, desc, last_name, 3 desc ;

It is also possible to specify a ** alias instad of the column name **.

AMPERSAND SUBSTITUTION
----------------------
*EVERY* element in a SELECT statement may be subsituted to facilitate reuse.

Substitution variables
----------------------
they are placeholders.

&variable (must be enclosed in single quotes foe character and dates '&variable')

Oracle Server
- processes teh statment
- notices a substitution variable
- attempts to resolve the substitution variables in 2 ways:
	1. First, checks if the variable is defined in the user session (see DEFINE)
	2. if not defined, the user process prompts for a value to be entered for substitution
- once the value is submitted, the statement is complete and is executed.

being resolved at runtime, "ampersand substitution" is also known as "runtime substitution" or "runtime binding"

NOTICE the differences:

SELECT employee_id
  from EMPLOYEES
 where last_name = &LASTNAME ;  // enter 'King' at prompt for substitution
    
SELECT employee_id
  from EMPLOYEES
 where last_name = '&LASTNAME' ;  // enter King at prompt for substitution

DOUBLE AMPERSAND SUBSTITUTION
-----------------------------

select first_name, last_name
from employees
where last_name like '%&SEARCH%'
  or first_name like '%&SEARCH%'

In this query you'll be promped twice for entering the same variable. This in inefficient:
1. typografical error would make the search criteria different
2. Oracle does not verify the values you entered are the same

when a variable occoures more then once in your SQL script, you may use the ** DOUBLE AMPERSAND SUBSTITUTION **
When Oracle Server encounters a double ampersand variable, a session value is defined for that variable and you are not promped to re-enter the value in subsequent occurrences. All subsequent run of the script woun't require to re-enter the values because they will be taken from the session.
To remove the variable from session, you must use the UNDEFINE command .

Queries with ampersand substitution may potentially benefit from Oracle automatic tuning.

Select &&a, &&a FROM DUAL; // prompts once
Select &&b,  &b FROM DUAL; // prompts once
Select  &c, &&c FROM DUAL; // prompts twice

It is also possible to use ampersand substitution in **column substitution**

substituting expressions and text
Almost any element may be substituted at runtime. The constraint is that Oracle requires at leas the firs word to be static.

SELECT &rest_of_statement ;

Session variables are created when they are initially referenced in SQL statements using DOUBLE AMPERSAND SUBSTITUTION. It won't happen using (SINGLE) AMPERSAND SUBSTITUTION. They'll exist untile the end of the session or untile they are UNDEFINED.

UNDEFINE variable;

DEFINE;		// lists all the session variables
DEFINE variable=value;	// creates a session variable named "variable" containing "value"

in SQL*Plus there are predefined variables prefixed with underscore (_). this is NOT a special character. You can define your variables prefixed with underscore.

Ampersand substitution may be disabled or anabled in SQL*Plus

SET define off
Select 'Coda & SID' from dual ;
SET define on

*****************************************************************
CHAPTER 4 - SINGLE ROW FUNCTIONS
*****************************************************************

round(42.39, 1) = 42.4
trunc(42.39, 1) = 42.3

mod(42, 10) = 2

months_between('01-FEB-2008', '01-JAN-2008') = 1
add_months('01-JAN-2008', 1) = 01-FEB-2008

LAST_DAY('01-FEB-2008') = 29-FEB-2008
NEXT_DAY('01-FEB-2008', 'Friday') = 08-FEB-2008

SYSDATE = 17-DEC-2007
ROUND(SYSDATE, 'MONTH') = 01-JAN-2008
TRUNC(SYSDATE, 'MONTH') = 01-DEC-2007

ORACLE SQL is complieant with ANSI:1999 and ISO:2003 standard

NVL2(), NULLIF(), COALESCE(), CASE()

** EXAM WATCH **
Singele row finctions are executed for each row in the dataset. This concept is implicitly tested via practical examples in the exam.
Functions line SUBSTR, INSTR and LENGTH are often used together and a thorought understanding of these is required. Remeber that implicit parameters that can be implicitly converted to data types required by functions are acceptable to Oracle.

LOWER('a MiXed CASE strING') = 'a mixed case string'  // lower case
UPPER('a MiXed CASE strING') = 'A MIXED CASE STRING'  // upper case
INITCAP('a MiXed CASE strING') = 'A Mixed Case String' // title case

select CONCAT(1+2.14, ' approximates pi') from dual;
> 3.14 approximates pi

select CONCAT('Today is ', SYSDATE) from dual;
> Today is 17-DEC-07

select LENGTH(1+2.14, ' approximates pi') from dual;
> 20

select LENGTH(SYSDATE) from dual;  // SYSDATE is implicitly converted to a CHAR (17-DEC-07)
> 9

select lpad(1000+200.55, 14, '*') from dual ;  // *******1200.55
select rpad(1000+200.55, 14, '*') from dual ;  // 1200.55*******
select lpad(sysdate, 14, '$#') from dual ;  // $#$#$01-JUN-15
select rpad(sysdate,  4, '$#') from dual ;  // 01-J

select TRIM('   no spaces   ') from dual ;  // [no spaces]
select TRIM(trailing 'e' from 1 + 2.14 || ' is pie') from dual ;  // [2.14 is pi]
select TRIM(leading '*' from '****Hidden****') from dual ;  // [Hidden****]
select TRIM(trailing '*' from '****Hidden****') from dual ;  // [****Hidden]
select TRIM(both '*' from '****Hidden****') from dual ;  // [Hidden]
// sysdate 01-JUN-10
select TRIM(0 from sysdate) from dual ;  // 1-JUN-1

NOTICE:
TRIM(s) = TRIM(both ' ' from s)
LTRIM(s) = TRIM(leading ' ' from s)
RTRIM(s) = TRIM(trailing ' ' from s)


INSTR(string, substring, [position], [occurrence])
returns 0 (zero) when no occurrence is found
`position` and `occurrence` default both to 1
+--------------------------------------------------------------------+
| WARNING: don't mix up with Java's String.indexOf() thet returns -1 |
+--------------------------------------------------------------------+
select INSTR('1#3#5#7#9#', '#') from dual ;  // 2
select INSTR('1#3#5#7#9#', '#', 5) from dual ;  // 6
select INSTR('1#3#5#7#9#', '#', 3, 4) from dual ;  // 10 (4th occurence since the 3rd character)
select INSTR('1#3#5#7#9#', '#', 5, 4) from dual ;  // 0  (4th occurence since the 5th character)
select INSTR('1#3#5#7#9#', '#', 1, 4) from dual ;  // 8  (4th occurence since the 1st character)



SUBSTR(source, start, [number of chars to extract])
if statr_position is negative, Oracle starts from the end of the string going backward. Number of chars to extract must be greater then zero (>0) otherwise NULL will be returned.

select SUBSTR(10000 - 3, 3, 2) from dual ;  // 97
select SUBSTR(sysdate, 4, 3) from dual ;  // JUN
select SUBSTR(10000 - 3, 8, 2) from dual ;  // NULL

select SUBSTR('1#3#5#7#9#',  5) from dual ;  // 5#7#9#
select SUBSTR('1#3#5#7#9#',  5, 6) from dual ;  // 5#7#9#
select SUBSTR('1#3#5#7#9#', -3) from dual ;  // #9#
select SUBSTR('1#3#5#7#9#', -3, 2) from dual ;  // #9
select SUBSTR('1#3#5#7#9#', -3, -2) from dual ;  // NULL
select SUBSTR('1#3#5#7#9#', -3, 0) from dual ;  // NULL

SUBSTR('1#3#5#7#9#', -3) = SUBSTR('1#3#5#7#9#', -3, 3)

REPLACE(source, search_string, [replace_term])
if replace term is omitted, the serch term is removed from the string

REPLACE('as a whole word', ' ', '') = REPLACE('as a whole word', ' ')

select REPLACE(10000 - 3, '9', '85') from dual ;  // 8585857
select REPLACE(10000 - 3,  9 ,  85 ) from dual ;  // 8585857
select REPLACE(sysdate, 'JUN', 'NOV') from dual ;  // 01-NOV-15
select REPLACE('1#3#5#7#9#', '#', '->') from dual ;  // 1->3->5->7->9->
select REPLACE('1#3#5#7#9#', '#') from dual ;  // 13579

SELECT FIRST_NAME, LAST_NAME, substr(first_name, 1, 1)||' '||substr(LAST_NAME,1,14) as formal_name FROM EMPLOYEES WHERE LENGTH(FIRST_NAME||LAST_NAME) > 15;

ROUND(source, decimal_precision);

select ROUND(1601.916718, 1) from dual ;  // 1601.9
select ROUND(1601.916718, 2) from dual ;  // 1601.92
select ROUND(1601.916718, -3) from dual ;  // 2000     *** NOTICE THIS ***
select ROUND(1601.916718) from dual ;  // 1602


TRUNC(source, decimal_precision);

select TRUNC(1601.916718, 1) from dual ;  // 1601.9
select TRUNC(1601.916718, 2) from dual ;  // 1601.91
select TRUNC(1601.916718, -3) from dual ;  // 1000     *** NOTICE THIS ***
select TRUNC(1601.916718) from dual ;  // 1601


MOD(dividend, divisor)   [modulus function]
MOD function is often used to classify even (pari) and odd (dispari) numbers
MOD(even_number, 2) = 0
MOD( odd_number, 2) = 1

select MOD(6,2) from dual ;  // 0
select MOD(5,3) from dual ;  // 2
select MOD(7,35) from dual ;  // 7
select MOD(5.2,3) from dual ;  // 2.2

Negative dividend negates the result sign (except 0)
select MOD(-6,2) from dual ;  // 0  ** NOTICE: -0 doesn't exist
select MOD(-5,3) from dual ;  // -2
select MOD(-7,35) from dual ;  // -7
select MOD(-5.2,3) from dual ;  // -2.2

Negative divisor doesn't negate the result sign
select MOD(6,-2) from dual ;  // 0    ** NOTICE THIS **
select MOD(5,-3) from dual ;  // 2    ** NOTICE THIS **
select MOD(7,-35) from dual ;  // 7    ** NOTICE THIS **
select MOD(5.2,-3) from dual ;  // 2.2    ** NOTICE THIS **

select first_name, last_name, MOD(employee_id, 4) as "Team#" from EMPLOYEES where employee_id between 100 and 111;

MONTHS_BETWEEN(start_date, end_date)
Notice MONTHS_BETWEEN is based on 31 days

select MONTHS_BETWEEN('18-AUG-15', '18-JUL-15') from dual ;  //  1  
select MONTHS_BETWEEN('18-JUL-15', '18-AUG-15') from dual ;  // -1  
select MONTHS_BETWEEN('18-JUL-15', '18-JUN-15') from dual ;  //  1  
select MONTHS_BETWEEN('18-JUL-15', '18-JUN-15') from dual ;  //  1  
select MONTHS_BETWEEN('18-JUN-15', '18-MAY-15') from dual ;  //  1  
select MONTHS_BETWEEN('18-AUG-15', '18-JUN-15') from dual ;  //  2  
select MONTHS_BETWEEN('18-AUG-15', '18-MAY-15') from dual ;  //  3  

select MONTHS_BETWEEN('29-MAR-2008', '28-FEB-2008') from dual ;  //  1.03225806
select MONTHS_BETWEEN('29-MAR-2008', '28-FEB-2008') * 31 from dual ; // 32


ADD_MONTHS(start_date, number_of_months)
if `number_of_months` has a fractional part, it will be ignored (truncated at the integer)
select ADD_MONTHS('07-APR-2009', 1) from dual ;  //  07-MAY-09
select ADD_MONTHS('31-DEC-2008', 2.01) from dual ;  //  28-FEB-09  ** NOTICE THIS **
select ADD_MONTHS('31-DEC-2008', 2.99) from dual ;  //  28-FEB-09  ** NOTICE THIS **
select ADD_MONTHS('07-APR-2009', -12) from dual ;  //  07-APR-08

SELECT employee_id, last_name, hire_date FROM employees WHERE months_between('01-JAN-2000', hire_date) > 100 ;

NEXT_DAY(start_date, day_of_the_week)

the 'day_of_the_week' value may be a character or a numeric. The acceptable values are determined by the NLS_DATE_LANGUEGE database parameter. Defaults are the three forst char of the day or an integer

select NEXT_DAY('01-JAN-2009', 't') from dual ;  // ERROR ORA-01846 invalid day of the week
select NEXT_DAY('01-JAN-2009', 'tu') from dual ;  // ERROR ORA-01846 invalid day of the week
select NEXT_DAY('01-JAN-2009', 'tue') from dual ;  // 06-JAN-09
select NEXT_DAY('01-JAN-2009', 'tues') from dual ;  // 06-JAN-09
select NEXT_DAY('01-JAN-2009', 'tuesd') from dual ;  // 06-JAN-09
select NEXT_DAY('01-JAN-2009', 'tuesday') from dual ;  // 06-JAN-09

select NEXT_DAY('01-JAN-2009',  3 ) from dual ;  // 06-JAN-09
select NEXT_DAY('01-JAN-2009', '3') from dual ;  // ERROR ORA-01846 invalid day of the week (it obviously cannot be cast)


LAST_DAY(start_date)


ROUND(start_date, [date_precision_format])

Rounds a date UP or DOWN to another date
`date_precision_format` defaults to 'day'

CC		century (NEAREST first day of the century)
YYYY	year (NEAREST first day of the year)
Q		Quarter (NEAREST first day of the quarter [trimestre])
MM		Month (NEAREST first day of the month)
W		Week (NEAREST first day of the week)
DD		Day [default] (NEAREST midnight )
HH		Hour (NEAREST sharp Hour)
MI		Minute (NEAREST sharp Minute)

select round('09-AUG-12', 'MM') from dual ;  // ERROR  ORA-01722: invalid number   ** NOTICE THIS **
select round(to_date('09-AUG-2012','DD-MM-YYYY'), 'MM') from dual ;  // rounds DOWN to 01-AUG-12
select round(to_date('09-AUG-2012','DD-MM-YYYY'), 'Q') from dual ;  // rounds DOWN to 01-JUL-12
select round(to_date('09-AUG-2012','DD-MM-YYYY'), 'W') from dual ;  // rounds DOWN to 08-AUG-12
select round(to_date('09-AUG-2012','DD-MM-YYYY'), 'CC') from dual ;  // rounds DOWN to 01-JAN-01  ** NOTICE THIS **
select round(to_date('09-AUG-2012','DD-MM-YYYY'), 'YYYY') from dual ;  // rounds UP to 01-JAN-13  ** NOTICE THIS **


TRUNC(start_date, [date_precision_format])

truncate a date DOWN to another date
`date_precision_format` defaults to 'day'

CC		century (first day of the DATE century)
YYYY	year (first day of the DATE year)
Q		Quarter (first day of the DATE quarter [trimestre])
MM		Month (first day of the DATE Month)
W		Week (first day of the DATE week)
DD		Day [default] (midnight of the DATE day)
HH		Hour (minute 00 of the DATE hour)
MI		Minute (second 00 of the DATE minute)

select TRUNC('09-AUG-12', 'MM') from dual ;  // ERROR  ORA-01722: invalid number   ** NOTICE THIS **
select TRUNC(to_date('09-AUG-2012','DD-MM-YYYY'), 'MM') from dual ;  // rounds DOWN to 01-AUG-12
select TRUNC(to_date('09-AUG-2012','DD-MM-YYYY'), 'Q') from dual ;  // rounds DOWN to 01-JUL-12
select TRUNC(to_date('09-AUG-2012','DD-MM-YYYY'), 'W') from dual ;  // rounds DOWN to 08-AUG-12
select TRUNC(to_date('09-AUG-2012','DD-MM-YYYY'), 'CC') from dual ;  // rounds DOWN to 01-JAN-01  ** NOTICE THIS **
select TRUNC(to_date('09-AUG-2012','DD-MM-YYYY'), 'YYYY') from dual ;  // rounds DOWN to 01-JAN-12

SELF TEST
1. B,C
2. A,D
3. B
4. A
5. B
6. C
7. C
8. A
9. A
10. C
LAB
select product_name, catalog_url, substr(catalog_url, 17, 6) as "SUP#"
  from product_information
  where instr(lower(product_description), 'color') > 0
    and instr(lower(product_description), 'printer') > 0


*****************************************************************
CHAPTER 5 - 
*****************************************************************

Converting numbers to characters
---------------------------------

TO_CHAR(number, [format_mask], [nls_parameter])

Format masks

9		Numeric width					9999 					12					12
0		leading zeroes					09999 					12					00012
.		Position of decimal point 		09999.999				030.40				00030.400
D		Position of decimal separator	09999D999				030.40				00030.400
,		Position of comma simbol		09999,999				03040				00003,040
G		Position of group separator		09999G999				03040				00003,040
$		Dollar sign						$099999					03040				$003040
L		Local currency 					L099999					03040				EUR003040 (if NLS_CURRENCY is set to EUR)
MI		Position of minus sign for 		99999MI					-03040				3040-
		negatives						
PR		Wrap negatives i parenthesis	99999PR					-03040				<3040>
EEEE	Scientific notation				99.99999EEEE			121.976				1.21976E+02
U		nls_dual_currency				U099999					03040				EUR003040 (if NLS_DUAL_CURRENCY is set to EUR)
V		multiplies by 10n times (n 		9999V99					3040				304000
		is the number of nines after V)	
S		+ or - sign is prefixed			S999999					3040				+3040


select TO_CHAR(1234.49, '99999.9') from DUAL; // 1234.5  ** NOTICE ** rounds UP !!
select TO_CHAR(1234.31, '99999.9') from DUAL; // 1234.3 
select TO_CHAR(1234.30001, '99999.9') from DUAL; // 1234.3 
select TO_CHAR(1234.30000, '99999.9') from DUAL; // 1234.3 
select TO_CHAR(1234.30, '99999.9') from DUAL; // 1234.3
select TO_CHAR(1234.3, '99999.9') from DUAL; // 1234.3
select TO_CHAR(1234.3076, '99999.999') from DUAL; // 1234.308  ** NOTICE ** rounds UP !!

Converting dates to characters
------------------------------
TO_CHAR(date, [date_format], [nls_parameter])

Y											5
YY											15
YYY											015
YYYY										2015
RR											15
YEAR										NINETEEN SEVENTY-FIVE
MM		numeric months 						06
MON											JUN
MONTH	case sensitive month				JUNE
D		Day of the week 					7
DD		2-digits day of the month			31
DDD		day of the year 					153
DY		Three-letters abbr.					MON
DAY		Case sensitive						MONDAY
Day		Case sensitive						Monday
W		Week of month 						4
WW		Week of year 						39
Q		Quarter of year 					4
CC		century 							20
S		Sign (preceding CC,YYYY or YEAR)	-1984
IYYY 	ISO date							1984
IYY 	ISO date							984
IY		ISO date							84
I		ISO date							4
BC,B.C.	
AD,A.D.	
J		Julian day (days since 31-dec-4713 B.C.)
IW		ISO week of the year
RM		Roman numeral month

AM,A.M.	Meridian indicator					
PM,P.M.	Meridian indicator					
HH		Hour of day (0..12)					
HH12	Hour of day (0..12)					
HH24	Hour of day (0..24)					
MI		Minutes (0..59)
SS		Seconds (0..59)
SSSSS	Seconds past midnight (0..86399)


-/.,?#! 						
"any character literal" 		
TH 						Positional or ordinal text
SP 						Spelled out number
THSP or SPTH			Spelled out positional or ordinal number

Select first_name, last_name, to_char(hire_date,'fmDay, "the "ddth "of" Month, Yyyysp') as START_DATE from employees where to_char(hire_date, 'fmDay') = 'Saturday' ;

Samples:

DEFINE birthday=to_date('27-MAR-1977','dd-mon-yyyy')

select '>'||TO_CHAR(&birthday, 'Day')||'<' from DUAL;  // >Friday   <

// 'fm' modifier removes trailing (on the right side) blanks 
select '>'||TO_CHAR(&birthday, 'fmDay')||'<' from DUAL;  // >Friday<

select '>'||TO_CHAR(&birthday, 'YEAR')||'<' from DUAL;  // >NINETEEN SEVENTY-SEVEN<
select '>'||TO_CHAR(&birthday, 'YYYYsp')||'<' from DUAL;  // >ONE THOUSAND NINE HUNDRED SEVENTY-SEVEN<
select '>'||TO_CHAR(&birthday, 'Yyyysp')||'<' from DUAL;  // >One Thousand Nine Hundred Seventy-Seven<

// TH for ordinal number: notice case is given by DD end not by TH
select '>'||TO_CHAR(&birthday, 'DDth')||'<' from DUAL;  // >27TH<
select '>'||TO_CHAR(&birthday, 'DDTH')||'<' from DUAL;  // >27TH<
select '>'||TO_CHAR(&birthday, 'ddth')||'<' from DUAL;  // >27th<
select '>'||TO_CHAR(&birthday, 'ddTH')||'<' from DUAL;  // >27th<

// use 'fm' when formatting with DAY or MONTH
select '>'||TO_CHAR(&birthday, 'Month, "the" ddth YYYY')||'<' from DUAL;  // >March	  , the 27th 1977<
select '>'||TO_CHAR(&birthday, 'fmMonth, "the" ddth YYYY')||'<' from DUAL;  // >March, the 27th 1977<

select '>'||TO_CHAR(&birthday, 'Day "the" ddth "of" Month YYYY')||'<' from DUAL;  // >Friday    the 27th of March	 1977<
select '>'||TO_CHAR(&birthday, 'fmDay "the" ddth "of" Month YYYY')||'<' from DUAL;  // >Friday the 27th of March 1977<

// SP spelled out number
select '>'||TO_CHAR(&birthday, 'DDsp MMsp YYYYsp')||'<' from DUAL;  // >TWENTY-SEVEN THREE ONE THOUSAND NINE HUNDRED SEVENTY-SEVEN<<
select '>'||TO_CHAR(&birthday, 'ddsp mmsp yyyysp')||'<' from DUAL;  // >twenty-seven three one thousand nine hundred seventy-seven<
select '>'||TO_CHAR(&birthday, 'Ddsp Mmsp Yyyysp')||'<' from DUAL;  // >Twenty-Seven Three One Thousand Nine Hundred Seventy-Seven<


** NOTICE THE DIFFERENCE **
'YEAR' and 'YYYYsp' returns the same value for years between xx00 and xx09 ...
select to_char(to_date('01-SEP-1909'), 'YEAR') from dual;   // ONE THOUSAND NINE HUNDRED NINE
select to_char(to_date('01-SEP-1909'), 'YYYYsp') from dual; // ONE THOUSAND NINE HUNDRED NINE
select to_char(to_date('01-SEP-2009'), 'YEAR') from dual;   // TWO THOUSAND NINE
select to_char(to_date('01-SEP-2009'), 'YYYYsp') from dual; // TWO THOUSAND NINE
... but different values for other years
select to_char(to_date('01-SEP-1910'), 'YEAR') from dual;   // NINETEEN TEN
select to_char(to_date('01-SEP-1910'), 'YYYYsp') from dual; // NINETEEN TEN
select to_char(to_date('01-SEP-2010'), 'YEAR') from dual;   // TWENTY TEN
select to_char(to_date('01-SEP-2010'), 'YYYYsp') from dual; // TWO THOUSAND TEN

// RM Roman numeral MONTH
select '>'||TO_CHAR(&birthday, 'DD RM YYYY')||'<' from DUAL;    // >27 III  1977<
select '>'||TO_CHAR(&birthday, 'fmDD RM YYYY')||'<' from DUAL;  // >27 III 1977<

// >27 March 1977 was the 86th day of the year<
select '>'||TO_CHAR(&birthday, 'fmDD Month YYYY "was the" dddth "day of the year"')||'<' from DUAL;
// >27 March 1977 was the eighty-sixth day of the year<
select '>'||TO_CHAR(&birthday, 'fmDD Month YYYY "was the" dddspth "day of the year"')||'<' from DUAL;



TO_DATE(string, [format], [nls_parameter])

the ** `fx` modifier **

select TO_DATE('25-DEC-2010') from dual; // 25-DEC-10 (it uses teh default mask DD-MON-YYYY)
select TO_DATE('25/DEC/2010') from dual;
select TO_DATE('25-DEC') from dual;  // ERROR
select TO_DATE('25-DEC', 'DD-MON') from dual; // 25-DEC-10
select TO_DATE('25-DEC-2010 18:03:45', 'DD-MON-YYYY HH24:MI:SS') from dual;  // OK
select TO_DATE('25-DEC-10',   'DD-MON-YYYY') from dual;  // OK ** Notice the difference in format
select TO_DATE('25-DEC-10', 'fxDD-MON-YYYY') from dual;  // ERROR 

TO_DATE and DEFAULTS

Day, when omitted defaults to 1
Month, when omitted is taken from SYSDATE
Year, when omitted is taken from SYSDATE
hour, minute, second: when omitted defaults to 0

select TO_DATE('25-DEC-2015', 'DD-MON-YYYY') from dual;  // time DEFAULTS to midnight 00:00:00
select TO_DATE('25-DEC', 'DD-MON') from dual; // 25-DEC-15
select TO_DATE('25', 'DD') from dual; // 25-JUN-15  ** NOTICE ** MONTH AND YEAR FROM SYSDATE
select TO_DATE('04', 'MM') from dual; // 01-APR-15 DD DEFAULTS TO 1 AND YEAR FROM SYSDATE
select TO_DATE('1988', 'YYYY') from dual;  // 01-JUN-1988  ** NOTICE ** DD DEFAULTS TO 1 AND MONTH FROM SYSDATE
select to_date('18','CC') from dual ;  // ERROR



TO_NUMBER(string, [format], [nls_parameter])

select to_number('$1,000.55') from dual; // ERROR
select to_number('$1,000.55', '$9G999D99') from dual; // OK
select to_number('$1,000.55', 'L9G999D99') from dual; 
alter session set 'NLS_NUMERIC_CHARACTERS=''.,'' '
select to_number('USD1,000.55', 'L9G999D99', 'NLS_CURRENCY=''USD''') from dual; 
select to_number('$1,000.55', 'L9G999D99', 'NLS_NUMERIC_CHARACTERS=''.,'' ') from dual;
select to_number('€1,000.55', 'L9G999D99', 'NLS_NUMERIC_CHARACTERS=''.,'' NLS_CURRENCY=''€'' ') from dual;


select NVL('B', 'A') from dual;   // B
select NVL(NULL, 'A') from dual;  // A

NVL2(original, ifnotnul, ifnull)
select NVL2('Z', 'A', 'B') from dual ;  // A
select NVL2(NULL, 'A', 'B') from dual ;  // B

COALESCE(term1, term2, ..., termN)
returns the first NOT NULL term from left to right
select COALESCE('A','B','C') from dual ;  // A
select COALESCE('A',NULL,NULL) from dual ; // A
select COALESCE(NULL,NULL,NULL) from dual ;  // NULL
select COALESCE(NULL,'B',NULL) from dual ;  // B

Notice
COALESCE(t1,t2) = NVL(t1,t2)
COALESCE(t1,t2,t3) = NVL(t1,NVL(t2,t3))

NULLIF(ifunequal, comparison_term)
select NULLIF(123,123) from dual;  // NULL
select NULLIF(123,122+1) from dual;  // NULL
select NULLIF(123,124) from dual;  // 123
select NULLIF('12-JUN-15','12-JUN-2015') from dual;  // 12-JUN-15 ** NOTICE THIS **
select NULLIF('123',123) from dual;  // ERROR: inconsistent data types ** NOTICE THIS **

Nesting NULLIF and NVL2 for simple condition logic

SELECT first_name, last_name, NVL2(NULLIF(length(first_name), length(last_name)), 'Different lenght', 'Same length') as name_lengths FROM EMPLOYEES WHERE DEPARTMENT_ID = 100 ;

DECODE()
** NOTICE ** DECODE() considers two NULLs to be equivalent


CASE statement comes in two variants

simple CASE expression
searched CASE expression


SELF TEST
1. B
2. D
3. D
4. C
5. B
6. A
7. B
8. A
9. C
10. B
LABS

SELECT CUST_FIRST_NAME, CUST_LAST_NAME, CUST_EMAIL, CUST_DATE_OF_BIRTH, 
case sysdate - date_of_birth
end birthday 
from customers 
where to_char(date_of_birth,'DAY') between to_char(SYSDATE - 2,'DAY') AND to_char(SYSDATE + 7, 'DAY') 
order by to_char(CUST_DATE_OF_BIRTH,'DD'), to_char(CUST_DATE_OF_BIRTH,'MM');


*****************************************************************
CHAPTER 6 - Group functions
*****************************************************************

NOTICE: Group funcion can be nested two levels deep !!

Select MIN(AVG(SUM(column))) from TABLE ;  // ERROR

COUNT(*|[ALL|DISTINCT] expr)



AVG([ALL|DISTINCT] expr)
expr MUST be NUMERIC

AVG(ALL expr) sums nonnull values and divides by the number of nonnull values.
AVG(DISTINCT expr) sums the distinct nonnull values and divides by the number of the distinct nonnull values.


SUM([ALL|DISTINCT] expr)
expr MUST be NUMERIC

MIN(ALL|DISTINCT expr)
MAX(ALL|DISTINCT expr)
expr may be NUMERIC, DATE or CHARACTER

select Max(first_name) from employees;
select Max(hire_date) from employees;
select Max(salary) from employees;

VARIANCE(DISTINCT|ALL expr)   ** Study this function **
expr MUST be NUMERIC


STDDEV(DISTINCT|ALL expr)     ** Study this function **
expr MUST be NUMERIC


Nested group functions
------------------------


GROUP BY and HAVING

select department_id 
  from employees 
 group by department_id 
having mod(department_id,20) = 0;  // OK department_id is in the projection

select department_id 
  from employees 
 group by department_id 
having length(last_name) > 12;  // ERROR: not a group by expression (last_name)

SELF TEST
1. C
2. B
3. A
4. C
5. C
6. D -> C
7. A
8. C
9. B
10. D -> B

** EXERCISE ON **
- Having clause with column not present in select statement or slightly different because of different functions.
- 

LABS
select product_status, count(*), sum(list_price) 
  from product_information 
 where lower(product_status) != 'orderable' 
 group by product_status 
 having sum(list_price) > 4000 ;

*****************************************************************
CHAPTER 7 - JOINING TABLES
*****************************************************************

NATURAL JOIN
--------------------

Oracle notation: returns 5 columns in which there are two occurences of REGION_ID (from both tables)

 select * 
  from regions r, countries c
 WHERE REGIoN_NAME = 'Americas'
   and r.region_id = c.region_id ; 

NATURAL JOIN removes automatically columns with the same name. NATURAL JOIN automatically joins over ALL columns with the same name, so it is not needed to specify what are the columns that make up the relation.

select * 
  from regions r NATURAL JOIN countries c
 WHERE r.REGION_NAME = 'Americas'; 

select r.REGION_NAME
  from regions r NATURAL JOIN countries c
 WHERE r.REGION_NAME = 'Americas'; 

** NOTICE **
Columns that are used for a named-join (either NATURAL JOIN or with the USING clause) cannot have an explicit qualifier.

** THIS IS NOT POSSIBLE ( alias.* ) **
select r.* 
  from regions r NATURAL JOIN countries c
 WHERE r.REGION_NAME = 'Americas';       // ERROR

SELECT * 
  FROM regions NATURAL JOIN sale_regions ;

JOIN ... USING
----------------------
sometimes more control is needed. It's possible to specify the colums on which make up the join condition with USING

select * 
  from regions r JOIN countries c USING (region_id)
 WHERE r.REGION_NAME = 'Americas'; 


JOIN ... ON
----------------------
JOIN ... ON allows to specify the columns o both sides of the relation.
This form is the most widely used

select * 
  from regions r JOIN countries c ON (r.region_id = c.region_id)
 WHERE r.REGION_NAME = 'Americas'; 


ALIASING
-------------
SELECT emp.employee_id, department_id, emp.manager_id, departments.manager_id
  FROM employees emp JOIN departments USING (department_id)
 WHERE department_id > 80 ;

SELECT emp.employee_id, department_id, emp.manager_id, manager_id
  FROM employees emp JOIN departments USING (department_id)
 WHERE department_id > 80 ;  // ERROR: column manager_id ambiguously defined

** NOTICE **
Columns that are used for a named-join (either NATURAL JOIN or with the USING clause) cannot have an explicit qualifier.

SELECT emp.employee_id, dep.department_id, emp.manager_id, dep.manager_id
  FROM employees emp JOIN departments dep USING (department_id)
 WHERE department_id > 80 ;  // ERROR on dep.department_id because of the explicit qualifier
